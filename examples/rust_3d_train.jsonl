{"instruction": "Create a three-rs mesh for a cube", "output": "use three::*;\n\nfn create_cube(size: f32) -> Mesh {\n    let geometry = Geometry::cuboid(size, size, size);\n    Mesh::new(geometry, Material::default())\n}"}
{"instruction": "Generate Bevy 3D scene setup with camera and light", "output": "use bevy::prelude::*;\n\nfn setup(mut commands: Commands) {\n    commands.spawn(Camera3dBundle {\n        transform: Transform::from_xyz(0.0, 5.0, 10.0).looking_at(Vec3::ZERO, Vec3::Y),\n        ..default()\n    });\n    commands.spawn(PointLightBundle {\n        point_light: PointLight {\n            intensity: 1500.0,\n            ..default()\n        },\n        transform: Transform::from_xyz(4.0, 8.0, 4.0),\n        ..default()\n    });\n}"}
{"instruction": "Write a function to create a sphere mesh in drei-rs", "output": "use drei::prelude::*;\n\npub fn create_sphere(radius: f32, segments: u32) -> Mesh {\n    let mut vertices = Vec::new();\n    let mut indices = Vec::new();\n    \n    for lat in 0..=segments {\n        let theta = std::f32::consts::PI * lat as f32 / segments as f32;\n        let sin_theta = theta.sin();\n        let cos_theta = theta.cos();\n        \n        for lon in 0..=segments {\n            let phi = 2.0 * std::f32::consts::PI * lon as f32 / segments as f32;\n            let x = sin_theta * phi.cos();\n            let y = cos_theta;\n            let z = sin_theta * phi.sin();\n            \n            vertices.push([x * radius, y * radius, z * radius]);\n        }\n    }\n    \n    Mesh::from_vertices(vertices, indices)\n}"}
{"instruction": "Create Blender Python script to add a cube at origin", "output": "import bpy\n\ndef add_cube_at_origin(size=2.0):\n    bpy.ops.mesh.primitive_cube_add(\n        size=size,\n        location=(0.0, 0.0, 0.0)\n    )\n    cube = bpy.context.active_object\n    cube.name = 'GeneratedCube'\n    return cube\n\nif __name__ == '__main__':\n    add_cube_at_origin()"}
{"instruction": "Generate point cloud to mesh conversion in Rust", "output": "use nalgebra as na;\nuse std::collections::HashMap;\n\npub fn point_cloud_to_mesh(points: &[na::Point3<f32>]) -> Mesh {\n    // Voxelize point cloud\n    let voxel_size = 0.1;\n    let mut voxel_map: HashMap<(i32, i32, i32), Vec<na::Point3<f32>>> = HashMap::new();\n    \n    for point in points {\n        let voxel = (\n            (point.x / voxel_size).floor() as i32,\n            (point.y / voxel_size).floor() as i32,\n            (point.z / voxel_size).floor() as i32,\n        );\n        voxel_map.entry(voxel).or_insert_with(Vec::new).push(*point);\n    }\n    \n    // Generate mesh from voxels\n    let vertices: Vec<[f32; 3]> = voxel_map.keys()\n        .map(|(x, y, z)| [\n            *x as f32 * voxel_size,\n            *y as f32 * voxel_size,\n            *z as f32 * voxel_size\n        ])\n        .collect();\n    \n    Mesh::from_vertices(vertices, vec![])\n}"}
{"instruction": "Write WGPU shader code for 3D mesh rendering", "output": "// Vertex Shader\n@vertex\nfn vs_main(\n    @location(0) position: vec3<f32>,\n    @location(1) normal: vec3<f32>,\n) -> VertexOutput {\n    var out: VertexOutput;\n    out.clip_position = camera.view_proj * vec4<f32>(position, 1.0);\n    out.world_position = position;\n    out.world_normal = normal;\n    return out;\n}\n\n// Fragment Shader\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {\n    let light_dir = normalize(vec3<f32>(1.0, 1.0, 1.0));\n    let ambient = 0.1;\n    let diffuse = max(dot(in.world_normal, light_dir), 0.0);\n    let lighting = ambient + diffuse;\n    return vec4<f32>(lighting, lighting, lighting, 1.0);\n}"}
{"instruction": "Create a spatial octree in Rust for 3D point partitioning", "output": "use nalgebra::Point3;\n\npub struct Octree {\n    center: Point3<f32>,\n    half_size: f32,\n    points: Vec<Point3<f32>>,\n    children: Option<Box<[Octree; 8]>>,\n}\n\nimpl Octree {\n    pub fn new(center: Point3<f32>, half_size: f32) -> Self {\n        Self {\n            center,\n            half_size,\n            points: Vec::new(),\n            children: None,\n        }\n    }\n    \n    pub fn insert(&mut self, point: Point3<f32>) {\n        const MAX_POINTS: usize = 8;\n        \n        if self.children.is_none() && self.points.len() < MAX_POINTS {\n            self.points.push(point);\n            return;\n        }\n        \n        if self.children.is_none() {\n            self.subdivide();\n        }\n        \n        let octant = self.get_octant(&point);\n        self.children.as_mut().unwrap()[octant].insert(point);\n    }\n    \n    fn get_octant(&self, point: &Point3<f32>) -> usize {\n        let mut octant = 0;\n        if point.x >= self.center.x { octant |= 1; }\n        if point.y >= self.center.y { octant |= 2; }\n        if point.z >= self.center.z { octant |= 4; }\n        octant\n    }\n    \n    fn subdivide(&mut self) {\n        // Implementation for subdividing octree\n    }\n}"}
{"instruction": "Generate CAD-style parametric cube in Rust", "output": "pub struct ParametricCube {\n    width: f32,\n    height: f32,\n    depth: f32,\n    position: [f32; 3],\n}\n\nimpl ParametricCube {\n    pub fn new(width: f32, height: f32, depth: f32) -> Self {\n        Self {\n            width,\n            height,\n            depth,\n            position: [0.0, 0.0, 0.0],\n        }\n    }\n    \n    pub fn at_position(mut self, x: f32, y: f32, z: f32) -> Self {\n        self.position = [x, y, z];\n        self\n    }\n    \n    pub fn to_mesh(&self) -> Mesh {\n        let hw = self.width / 2.0;\n        let hh = self.height / 2.0;\n        let hd = self.depth / 2.0;\n        let [x, y, z] = self.position;\n        \n        let vertices = vec![\n            [x - hw, y - hh, z - hd], [x + hw, y - hh, z - hd],\n            [x + hw, y + hh, z - hd], [x - hw, y + hh, z - hd],\n            [x - hw, y - hh, z + hd], [x + hw, y - hh, z + hd],\n            [x + hw, y + hh, z + hd], [x - hw, y + hh, z + hd],\n        ];\n        \n        let indices = vec![\n            0, 1, 2, 0, 2, 3,  // Front\n            4, 6, 5, 4, 7, 6,  // Back\n            0, 3, 7, 0, 7, 4,  // Left\n            1, 5, 6, 1, 6, 2,  // Right\n            3, 2, 6, 3, 6, 7,  // Top\n            0, 4, 5, 0, 5, 1,  // Bottom\n        ];\n        \n        Mesh { vertices, indices }\n    }\n}"}
